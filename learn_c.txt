automatic variables are local vars, that are created when the function is called, and destroyed when the function exits
  `static` makes such a variable keep its value between calls
global vars are _defined_ exactly once, outside of any function
  defining allocates storage for the var
global vars must be _declared_ in each function that want to access them
  can be explicit: extern char c;
  or implicit, if the global var is _defined_ in the source file before it's used
    common practice: put all definitions of global vars in headers
  if var is defined in another .c file, it must be declared `extern` explicitly
    functions define in another .c file must also be declared `extern`, but they're already that implicitly

variables shouldn't be named to start with `_`, as libraries use that convention
types:
  char // byte
  int // natural size of integers in the host machine; at least 16 bits
  float // single precision float
  [long] double // double precision float
  short [int] // at least 16 bits
  long [int] // at least 32 bits
all the char and int types can be `unsigned`
float and double can have larger absolute values than integers, when both have the same number of bits, but with less precision
  http://stackoverflow.com/questions/11158476/why-do-float-and-int-have-such-different-maximum-values-even-though-theyre-the
  floats and doubles lose precision with large numbers even before the decimal point
constants/literals:
  1234 // int
  123456789l or 123456789L // long; literals too big to fit in an int are also implicitly long
  123456789u or 123456789U // unsigned
  123.4 // double
  1e-2 // double
  123.4f or 123.4F // float
  123.4l or 123.4L // long double
  01234 // octal, i.e. base-8
  0x1234 or 0X1234 // hex, i.e. base-16
  0xFUL // unsigned long with value 15 in decimal
  'a' // int
  '\123' // int from octal value
  '\x6F' // int from hex value
  "bla" // string literal with trailing '\0'
constant expressions contain only constants/literals, and can be eval'd at compile time
stdlib's strlen() (in string.h) returns the length _without_ the trailing '\0'
concatenation: "some string" "another string"
enum:
  enum boolean { NO, YES } // values 0 and 1
  enum chars { BELL = '\a', TAB = '\t', CHAR_A = 'a' }
  enum months { JAN = 1, FEB, MAR } // unspecified values continue counting up from the last specified value
  names in different enums must be distinct, but values don't, even in the same enum

all vars must be declared before use:
  int i;
  char c;
var can be initialized in the decl, with an expression:
  int i = INT_MAX - 1;
  char c = 'a';
non-automatic vars are initialized once, before program starts executing
  the initializer for these can only be a constant-expression
automatic vars are initialized each time the function is called
  the initializer for automatic and `register` vars can be any expression (even function calls)
external (outside functions) and static vars (inside functions) without explicit initializers are initialized to 0 by default
automatic vars (i.e. non-static function vars) and `register` vars without explicit initializers are initialized to undefined (i.e. garbage) by default
guideline: if it incurs a runtime performance cost, a var is not initialized to 0, but undefined, by default
`const` can be added to any decl
  for an array this means that the elements won't be altered
  parameters can also have const: void foo(const arr[])
  what happens when changing a const var is attempted is _implementation-defined_
arrays can be initialized with an initializer-list
  char foo[] = {'b', 'a', 'r', '\0'}
  if there are less initializers than the array size, the remaining values will be 0
  NOTE: C forbids empty initializer braces; at least one initializer is required
    int arr[10] = {}; // wrong, results in compiler warning; in C++ this would be ok
    int arr[10] = {0}; // ok, initializes all elements to 0

the modulus operator % can only be applied on integers, not floats
using % on negative values results in _machine-dependent_ sign of the result, and using / results truncation towards 0 or away from it; DON'T use these on negative values in C89
  c99 defined truncation to always be towards 0 for negative values
  http://stackoverflow.com/a/29179586
  http://python-history.blogspot.fi/2010/08/why-pythons-integer-division-floors.html
operator precedence table: http://en.cppreference.com/w/c/language/operator_precedence
in C, unary plus won't change a negative value into a positive value
  edit: neither does it in JS or PHP

in general, the only automatic conversions convert from narrower type to wider type
  exception: float is not converted to double
converting from wide to narrow (i.e. from int to char) is not illegal, but compiler might show a warning
converting between unsigned and signed is machine-dependent, because it depends on the sizes of types. if int is 16 bits and long is 32 bits:
  -1L < 1U // 1U is converted to signed long
    appendix A6.5: "...the effect depends on whether a long int can represent all values of an unsigned int..."
  -1L > 1UL // -1L is converted to unsigned long; its bit pattern makes it look like a large positive int
    appendix A6.5: "if either operation is unsigned long int, the other is converted to unsigned long int"
conversion also happens in function calls, if the parameter type is different than the argument type
DON'T mix signed and unsigned types
appendix section A6 lists all conversion rules
when a char is converted to int, it can result in a negative or positive value
  char in C is signed or unsigned, depending on implementation
  therefore ALWAYS set char explicitly to signed or unsigned, when a char is used for arbitrary bit patterns (i.e. non-char data, e.g. as a small int)
the conditional operators (||, &&, >, <, etc.) return 0 or 1
casting uses the same conversion rules: (unsigned long) -1L;

bitwise operators can only be used on integer types (signed or unsigned)
^ // exclusive or
~ // one's complement (i.e. inverts all bits)
<< // left-shifting always right-pads with 0
>> // right-shifting always left-pads unsigneds with 0, and either pads signeds with 0 ("logical shift") or with the sign bit ("arithmetic shift") machine-dependently

the operands of an expression with the operators &&, ||, ?: and , are guaranteed to be evaluated left-to-right
the evaluation order for other operands is NOT guaranteed
  therefore this might cause problems: foo(++n, n); // second argument might be n or n+1
  also problematic: a[i] = i++;

each 1-bit represents a power of two:
  0001: 1
  0010: 2
  0100: 4
  1000: 8
in hex (e.g. in printf("%x\n", 8)) a single character represents 4 bits (2^4)
  4 bits is "a nibble" (half of a byte)
  0x08: 8
  0x0F: 15
  0xFF: 255

C allows a function declaration to omit the argument list (for backwards compatibility), even if the definition has arguments
  int foo();
  int main() { foo( 123, 456 ); }
  int foo( int a ) { printf("%d", a); }
  ^ this compiles without errors. to make the compiler output an error, use `void`: int foo(void);
    therefore all empty argument lists should have `void`Â in the declaration (for compile-time checking)

by default, external variables (i.e. those _defined_ outside of functions) and functions have "external linkage"
  this means that function even in other .c files (i.e. "compilation units") can access those vars and functions

you cannot declare a new variable in a switch-case statement, because the `case` is only a label
  "error: a label can only be part of a statement and a declaration is not a statement"
  REMEMBER: C has block scope, so you can create a new scope in the `case` with {}
  http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement
  http://stackoverflow.com/questions/2759371/in-c-do-braces-act-as-a-stack-frame

the scope of an external var (i.e. var declared outside of function) and an external function ("extern" is the default) spans from the point where it is declared to the end of the file
  this is why we need "forward-declaration" to access vars and functions further down in the same file
  NOTE: you need `extern` to _declare_ a variable
    int a; // this is a definition
    extern int a; // this is a declaration
external vars must be defined only once across all files, but can be declared multiple times
  arrays need a size on definition, but not on declaration
an external var can only be initialized in its definition
contrary to `extern`, `static` will limit a var's or function's scope to only the file it's in
`static` in a function makes the var retain its state across calls (works just like in PHP)
  these are initialized only once, when the block is first entered
`register` advises the compiler that the var will be heavily used. compiler might ignore this.
  can only be used in automatic vars and parameters
  you cannot take the address of a `register` var

#defines can span multiple lines, if you put `\` at the end of the line
scope of a #define is from the point of definition to the end of the compiled file
substitutions are only made for full tokens, not if the identifier is part of a longer token, string, or comment:
  #define YES something
  printf("YES") // not substituted
  foo(YESMAN) // not substituted
  foo(YES) // is substituted
  modern C compilers allow unicode in the identifier: http://stackoverflow.com/questions/34319000/what-constitutes-a-valid-c-identifier
any replacement text is allowed:
  #define infinite_loop while (1)
allows for arguments:
  #define max(A, B) ((A) > (B) ? (A) : (B))
  this is dangerous, as the args are evaluated twice, so max(i++, j++) would give non-intuitive results
#defines can be removed with #undef
preceding a parameter name with `#` wraps it with quotes:
  #define printdebug(expr) printf("Debug: " #expr "\n")
  escaping is automatic: in `expr` the " char is replaced with \" and the \ char with \\
## does concatenation of the macro arguments
  #define baz(foo, bar) foo ## bar
  ^ results in `foobar`, because the ## operator replaces whitespace around it
a #define is also expanded inside any following #define
  #define FOO "foo"
  #define FOOBAR FOO "bar"
  printf(FOOBAR);
conditionals:
  #if // this can have any constant integer (not float) expression (but no `sizeof`, casts or enums)
  #elif // as above
  #else
  #endif
  #if defined(name)    is the same as    #ifdef(name)
  #if !defined(name)    is the same as    #ifndef(name)

the `&` operator gives the address of a variable or an array element
  it cannot be used on expressions, constants (i.e. literals like 1000.0L) and `register` vars
the pointer operators & and * have higher precedence than arithmetic operators like +, /,  etc.
  *ptr = *ptr + 1;
  *ptr += 1;
  ++*ptr;   // the unary operators associate right-to-left, and
  (*ptr)++; // associate right-to-left; that's why postfix increment need parens
